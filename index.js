
const bunyan = require('bunyan')
const dns = require('dns')

const { KubeAdapter } = require('./lib/kube-adapter')
const { NetpolManager } = require('./lib/network-policy')

const logger = bunyan.createLogger({ name: 'dns-network-policy-generator', level: 'trace' })

const kubeAdapter = new KubeAdapter({
  logger
})

const netpol = new NetpolManager({
  kubeAdapter,
  logger
})

// lookup for setTimeout handlers
// const pollDnsTimers = {}
function pollDns (dnsTrackObject) {
  // for now, we just handle a single dns entry
  if (dnsTrackObject.dnsRecords.length !== 1) {
    logger.error({ dnsRecords: dnsTrackObject.dnsRecords }, 'as of now, we only support single dns entries.')
    return
  }
  const dnsName = dnsTrackObject.dnsRecords[0].dns
  dns.resolve4(dnsName, { ttl: true }, async (err, addresses) => {
    if (err) {
      logger.error({ err, dnsName, ruleName: dnsTrackObject.ruleName }, 'failed to resolve dns record')
      return
    }
    logger.debug({ addresses, dnsName, ruleName: dnsTrackObject.ruleName }, 'dns resolved')
    const npName = netpol.generateNetpolName(dnsTrackObject.ruleName)
    // TODO: namespace support to be added
    const targetNamespace = 'default'
    const existingNetpol = await kubeAdapter.getNetworkPolicyByName(npName)
    // we generate the object for the new netpol anyways, so it can be compared to the existing one
    const npResource = netpol.generateNetpolObject({
      name: npName,
      namespace: targetNamespace,
      addresses: addresses.map(addrObj => addrObj.address),
      ruleName: dnsTrackObject.ruleName
    })
    if (existingNetpol) {
      // first check for labeling indicates that we manage this netpol
      if (existingNetpol.metadata.labels['generated-by'] !== 'npfd') {
        // a network policy with the desired name already exists. However, based on the label its not generated by us.
        // log an error and leave it untouched.
        logger.error({ npName, ruleName: dnsTrackObject.ruleName }, 'NetworkPolicy with given name already exists, however has no "generated-by" label as expected. Generation aborted, netpol will remain untouched.')
        return
      }
      if (existingNetpol.metadata.labels['npfd-generated-from'] !== dnsTrackObject.ruleName) {
        logger.error({ npName, triggeringRuleName: dnsTrackObject.ruleName, generatedForRuleName: existingNetpol.metadata.labels['npfd-generated-from'] }, 'existing netpol was generated from another rule. Generation aborted, netpol will remain untouched.')
        return
      }
      const diffReport = netpol.reportDiff(existingNetpol, npResource)
      logger.info({ diffReport }, 'diff report on existing netpol')
      // TODO: check diff report, log it and take necessary actions
    } else {
      logger.debug({ npName, ruleName: dnsTrackObject.ruleName, netpolResouce: npResource }, 'attempting to generate a new netpol')
      await kubeAdapter.createNetworkPolicy(npResource, targetNamespace)
      logger.info({ npName, ruleName: dnsTrackObject.ruleName, dnsName }, 'netpol created')
    }
  })
}

async function main () {
  try {
    await kubeAdapter.initKubernetesClient()
    await kubeAdapter.assertCrdExists()

    // watch for entries
    netpol.watchDnsNetworkPolicies((dnsTrackObject, eventData) => {
      if (eventData.action === 'createOrUpdate') {
        pollDns(dnsTrackObject)
      } else {
        logger.error({ dnsTrackObject, eventData, action: eventData.action }, 'action handler not implemented yet')
      }
    })
  } catch (err) {
    console.error('Error: ', err)
    process.exit(1)
  }

  kubeAdapter.on('error', (err) => {
    logger.fatal({ err }, 'Received error event on the kubernetes json stream')
    process.exit(2)
  })
}

main()
